#N canvas 94 32 1572 1344 16;
#X obj 34 15 inlet;
#X obj 971 48 inlet dollar_zero;
#X obj 71 310 nnb.range;
#X obj 71 282 f;
#X obj 450 118 s \$0_nnb_n_prev;
#X obj 404 149 s \$0_nnb_n;
#X obj 219 87 s \$0_nnb_layer;
#X obj 971 76 s \$0_nnb_d0;
#X obj 92 253 r \$0_nnb_n;
#X obj 404 87 list split 1;
#X obj 34 210 t b b;
#X obj 71 545 nn.bp.dz_1, f 138;
#X obj 34 52 route bang layer_number layer_dims activation leak, f 116;
#X obj 711 213 s \$0_nnp_activation;
#X obj 774 88 s \$0_nnp_leak;
#X obj 1172 517 r \$0_nnp_activation;
#X obj 988 517 r \$0_nnp_leak;
#X obj 254 477 nnb.array_name da;
#X obj 437 477 nnb.array_name z;
#X obj 620 477 nnb.array_name a;
#X obj 804 477 nnb.array_name dz;
#X obj 387 448 r \$0_nnb_d0;
#X obj 342 420 r \$0_nnb_layer;
#X obj 562 448 r \$0_nnb_d0;
#X obj 520 420 r \$0_nnb_layer;
#X obj 745 448 r \$0_nnb_d0;
#X obj 703 420 r \$0_nnb_layer;
#X obj 937 448 r \$0_nnb_d0;
#X obj 892 420 r \$0_nnb_layer;
#X obj 71 338 t b f f f f, f 92;
#X obj 254 366 t b f;
#X obj 437 366 t b f;
#X obj 620 366 t b f;
#X obj 804 366 t b f;
#X obj 589 119 select relu tanh sigmoid linear;
#X msg 589 152 1;
#X msg 650 152 2;
#X msg 711 152 3;
#X msg 770 152 4;
#X msg 834 152 0;
#X obj 589 87 symbol;
#X obj 71 700 nnb.range;
#X obj 71 672 f;
#X obj 92 643 r \$0_nnb_n;
#X obj 34 600 t b b;
#X obj 71 728 t b f f f f, f 92;
#X obj 254 756 t b f;
#X obj 437 756 t b f;
#X obj 620 756 t b f;
#X obj 804 756 t b f;
#X obj 66 1056 nn.bp.dw_1x3, f 48;
#X obj 141 916 r \$0_nn.bp_dz_0;
#X obj 217 944 r \$0_nn.bp_a_prev_0;
#X obj 293 972 r \$0_nn.bp_a_prev_1;
#X obj 370 1000 r \$0_nn.bp_a_prev_2;
#X obj 447 1028 r \$0_nn.bp_dw_0;
#X text 142 802 // TODO: modify this function to take a slice of a_prev arrays? But with an unknown number of a_prev arrays it might be better to just calculate one dw column at a time... I'm thinking the workaround is to figure out how to create a function that takes an unknown number of args;
#X text 672 1003 // this seems to be the way to go \, it's the same number of calculations:;
#X obj 672 1063 nn.dw_1x1;
#X text 48 1172 // For dA_prev \, look at nn.da_1x1;
#X connect 0 0 12 0;
#X connect 1 0 7 0;
#X connect 2 0 29 0;
#X connect 3 0 2 0;
#X connect 8 0 3 1;
#X connect 9 0 5 0;
#X connect 9 1 4 0;
#X connect 10 0 44 0;
#X connect 10 1 3 0;
#X connect 12 0 10 0;
#X connect 12 1 6 0;
#X connect 12 2 9 0;
#X connect 12 3 40 0;
#X connect 12 4 14 0;
#X connect 15 0 11 6;
#X connect 16 0 11 5;
#X connect 17 0 11 1;
#X connect 18 0 11 2;
#X connect 19 0 11 3;
#X connect 20 0 11 4;
#X connect 21 0 17 3;
#X connect 22 0 17 2;
#X connect 23 0 18 3;
#X connect 24 0 18 2;
#X connect 25 0 19 3;
#X connect 26 0 19 2;
#X connect 27 0 20 3;
#X connect 28 0 20 2;
#X connect 29 0 11 0;
#X connect 29 1 30 0;
#X connect 29 2 31 0;
#X connect 29 3 32 0;
#X connect 29 4 33 0;
#X connect 30 0 17 0;
#X connect 30 1 17 1;
#X connect 31 0 18 0;
#X connect 31 1 18 1;
#X connect 32 0 19 0;
#X connect 32 1 19 1;
#X connect 33 0 20 0;
#X connect 33 1 20 1;
#X connect 34 0 35 0;
#X connect 34 1 36 0;
#X connect 34 2 37 0;
#X connect 34 3 38 0;
#X connect 34 4 39 0;
#X connect 35 0 13 0;
#X connect 36 0 13 0;
#X connect 37 0 13 0;
#X connect 38 0 13 0;
#X connect 39 0 13 0;
#X connect 40 0 34 0;
#X connect 41 0 45 0;
#X connect 42 0 41 0;
#X connect 43 0 42 1;
#X connect 44 1 42 0;
#X connect 45 1 46 0;
#X connect 45 2 47 0;
#X connect 45 3 48 0;
#X connect 45 4 49 0;
#X connect 51 0 50 1;
#X connect 52 0 50 2;
#X connect 53 0 50 3;
#X connect 54 0 50 4;
#X connect 55 0 50 5;
